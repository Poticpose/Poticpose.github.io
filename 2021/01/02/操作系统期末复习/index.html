
<!DOCTYPE html>
<html lang="zh-CN" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>操作系统期末复习 - 诗文的小书屋</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="blog,"> 
    <meta name="description" content="第一章 操作系统（OS）引论操作系统的目标

方便性
有效性
可扩充性
开放性

操作系统的作用

OS 作为用户与计算机硬件系统之间的接口
  

OS 作为计算机系统资源的管理者，资源分为：

,"> 
    <meta name="author" content="Poet"> 
    <link rel="alternative" href="atom.xml" title="诗文的小书屋" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    
<link rel="stylesheet" href="/css/diaspora.css">

	<script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <script>
         (adsbygoogle = window.adsbygoogle || []).push({
              google_ad_client: "ca-pub-8691406134231910",
              enable_page_level_ads: true
         });
    </script>
    <script async custom-element="amp-auto-ads"
        src="https://cdn.ampproject.org/v0/amp-auto-ads-0.1.js">
    </script>
<meta name="generator" content="Hexo 4.2.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">诗文的小书屋</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://poticpose.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">操作系统期末复习</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">操作系统期末复习</h1>
        <div class="stuff">
            <span>一月 02, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>


        </div>
        <div class="content markdown">
            <h2 id="第一章-操作系统（OS）引论"><a href="#第一章-操作系统（OS）引论" class="headerlink" title="第一章 操作系统（OS）引论"></a>第一章 操作系统（OS）引论</h2><p><b>操作系统的目标</b></p>
<ul>
<li>方便性</li>
<li>有效性</li>
<li>可扩充性</li>
<li>开放性</li>
</ul>
<p><b>操作系统的作用</b></p>
<ul>
<li><p>OS 作为用户与计算机硬件系统之间的接口</p>
  <img src='/img/操作系统期末复习/img4.jpg'>
</li>
<li><p>OS 作为计算机系统资源的管理者，资源分为：</p>
<ul>
<li>处理机</li>
<li>存储器</li>
<li>I/O 设备</li>
<li>文件</li>
</ul>
</li>
<li><p>OS 实现了对计算机资源的抽象</p>
  <img src='/img/操作系统期末复习/img5.jpg'>

</li>
</ul>
<p>&nbsp;</p>
<p><b>操作系统的基本特性</b></p>
<p><b>并发</b> <font color='red'>★★★</font></p>
<ul>
<li><p>并行与并发</p>
<p>  并行性指两个或多个事件在同一时刻发生。而并发性是指两个或多个事件在同一时间间隔内发生。</p>
<p>  单处理机系统内，微观上并行是这些程序分时的交替执行。如 1 秒内有四个程序并行，实际是 0-15 ms 程序 A 运行；15-30 ms 程序 B 运行；30-45 ms 程序 C 运行；45-60 ms 程序 D 运行。</p>
</li>
<li><p>引入进程</p>
<p>  在未引入进程前，同一应用的计算程序和 I/O 程序只能顺序执行。若为两者分别建立一个进程，这两个进程便可以并发执行，这样便能<b>极大地提高系统资源利用率，增加系统吞吐量</b>。</p>
<p>  进程是指<b>系统中能独立运行并作为资源分配的基本单位</b>。它由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实体。<b>进程和并发是现代操作系统中最重要的基本概念，也是操作系统运行的基础</b>。</p>
</li>
</ul>
<p><b>共享</b></p>
<p>指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<ul>
<li><p>互斥共享方式</p>
<p>  系统中某些资源可以提供给多个进程使用，但规定在一段时间内，只允许一个进程访问该资源。将这种一段时间内只允许一个进程访问的资源，称为<b>临界资源</b>。</p>
</li>
<li><p>同时访问方式</p>
<p>  单处理环境下，宏观上是“同时”，微观上，进程对资源的访问时交替进行的。</p>
</li>
</ul>
<p><b>虚拟</b></p>
<p>OS 中，把通过某种技术将一个物理实体变成若干个逻辑上的对应物的功能称为“虚拟”。</p>
<ul>
<li><p>时分复用技术</p>
<p>  该技术提高资源利用率的根本原因在于，它利用某设备为一用户服务的空闲时间，又转去为其他用户服务，使设备得到最充分的利用。</p>
<ul>
<li>虚拟处理机技术</li>
<li>虚拟设备技术</li>
</ul>
</li>
<li><p>空分复用技术</p>
<p>  例如将一个较大存储空间分成较多的窄小存储空间。</p>
</li>
</ul>
<p><b>异步</b></p>
<p>进程通常不能一次性完成工作，而是段进式的，最后利用资源的进程可能工作量较小，最先利用资源的进程可能工作量较大，因此最后利用资源的进程反而有可能最先完成工作，这便是异步。</p>
<p>操作系统的四大基本特性：</p>
<ul>
<li>并发</li>
<li>共享</li>
<li>虚拟</li>
<li>异步</li>
</ul>
<p>&nbsp;</p>
<p><b>操作系统的主要功能</b></p>
<p><b>处理机管理功能</b></p>
<ul>
<li><p>进程控制</p>
<p>  为作业创建进程、撤销已结束的进程，以及控制进程在运行过程中的状态转换。</p>
</li>
<li><p>进程同步</p>
<p>  为多个进程的运行进行协调。实现进程同步最常用的机制是信号量机制。</p>
</li>
<li><p>进程通信</p>
<p>  事先相互合作进程之间的信息交换。</p>
</li>
<li><p>调度</p>
<ul>
<li>作业调度：从后备队列中按照一定的算法选择出若干作业，为它们分配运行所需的资源，再将这些作业调入内存后，分别为他们建立进程，并插入就绪队列中。</li>
<li>进程调度：从进程的就绪队列中按照一定的算法选出一个进程，将处理机分配给它，并为它设置运行现场，使其投入执行。</li>
</ul>
</li>
</ul>
<p><b>存储器管理功能</b></p>
<ul>
<li><p>内存分配</p>
<ul>
<li><p>为每道程序分配内存空间。</p>
</li>
<li><p>提高存储器利用率。</p>
</li>
<li><p>允许正在运行的程序申请附加的内存空间。</p>
<ul>
<li>静态分配方式：装入时即确定空间，不可变。</li>
<li>动态分配方式：允许后续申请新的附加空间。</li>
</ul>
</li>
</ul>
</li>
<li><p>内存保护</p>
<ul>
<li>确保每道用户程序仅在自己的内存空间内运行。</li>
<li>绝不允许用户程序访问操作系统的程序和数据。</li>
</ul>
</li>
<li><p>地址映射</p>
<p>  将地址空间中的逻辑地址转换为内存空间中与之对应的物理地址。</p>
</li>
<li><p>内存扩充</p>
<p>  逻辑上扩充内存容量，用于实现：请求调入功能、置换功能。</p>
</li>
</ul>
<p><b>设备管理功能</b></p>
<p>主要任务有：</p>
<ol>
<li><p>完成用户进程提出的 I/O 请求，为用户进程分配所需的 I/O 设备，并完成指定的 I/O 操作。</p>
</li>
<li><p>提高 CPU 和 I/O 设备的利用率，提高 I/O 速度，方便用户使用 I/O 设备。</p>
</li>
</ol>
<ul>
<li><p>缓存管理</p>
<p>  如果在 I/O 设备和 CPU 之间引入缓冲，则可有效地缓和 CPU 和 I/O 设备速度不匹配的矛盾，提高 CPU 利用率，进而提高系统吞吐量。</p>
</li>
<li><p>设备分配</p>
<p>  根据用户进程的 I/O 请求、系统现有资源情况以及按照某种设备分配策略，为之分配其所需的设备。</p>
</li>
<li><p>设备处理</p>
<p>  实现 CPU 和设备控制器之间的通信，即由 CPU 向设备控制器发出 I/O 命令，要求它完成指定的 I/O 操作。</p>
</li>
</ul>
<p><b>文件管理功能</b></p>
<p>对用户文件和系统文件进行管理以方便用户使用，并保证文件的安全性。</p>
<ul>
<li><p>文件存储空间的管理</p>
<p>  为每个文件分配必要的外存空间，提高外存的利用率，进而提高文件系统的存、取速度。</p>
</li>
<li><p>目录管理</p>
<p>  为每个文件建立一个目录项，目录项包括文件名、文件属性、文件在磁盘上的物理位置等，并对众多的目录项加以有效地组织，以实现方便的按名存取。</p>
</li>
<li><p>文件的读/写管理和保护</p>
<ul>
<li><p>文件的读/写管理：根据用户的请求，从外存中读取数据，或将数据写入外存。</p>
</li>
<li><p>文件保护：</p>
<ol>
<li>防止未经核准的用户存取文件。</li>
<li>防止冒名顶替存取文件。</li>
<li>防止以不正确的方式使用文件。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>&nbsp;</p>
<p><b>操作系统与用户之间的接口</b></p>
<ul>
<li><p>用户接口 <font color='red'>★★★</font></p>
<p>  为方便用户直接或间接地控制自己的作业，操作系统向用户提供了命令接口。用户可通过该接口向作业发出命令以控制作业的运行。该接口又进一步分为联机用户接口、脱机用户接口和图形用户接口。</p>
<ol>
<li>联机用户接口：为联机用户提供，由一组键盘操作命令和命令解释程序组成。当用户在终端或控制台上键入一条命令后，系统便立即转入命令解释程序，对该命令加以解释执行。</li>
<li>脱机用户接口：为批处理作业的用户提供，用户用作业控制语言 JCL 把需要对作业进行的控制和干预命令事先写在作业说明书上，然后把它与作业一同提供给系统。</li>
<li>图形用户接口：采用图形化操作界面，通过图标将系统各项功能、各种应用程序和文件直观表示。</li>
</ol>
</li>
<li><p>程序接口 <font color='red'>★★★</font></p>
<p>  为用户程序在执行中访问系统资源而设置的，是用户程序取得操作系统服务的唯一途径。它由一组系统调用组成。</p>
</li>
</ul>
<hr>
<h2 id="第二章-进程的描述与控制"><a href="#第二章-进程的描述与控制" class="headerlink" title="第二章 进程的描述与控制"></a>第二章 进程的描述与控制</h2><p><b>进程的定义</b> <font color='red'>★★★</font></p>
<p>为了使参与并发执行的每个程序都能独立地运行，在操作系统中必须为之配置一个专门的数据结构，称为<b>进程控制块（PCB）</b>。系统利用 PCB 来描述进程的基本情况和活动过程，进而控制和管理进程。这样，<b>由程序段、数据段和 PCB 三部分便构成了进程实体</b>。</p>
<p>对进程的不同定义：</p>
<ol>
<li>进程是程序的一次执行。</li>
<li>进程是一个程序机器数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>
</ol>
<p>传统定义：<b>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</b></p>
<p><b>进程的特征</b></p>
<ul>
<li>动态性：进程最基本的特征。</li>
<li>并发性：多个进程实体同存于内存中，能在一段时间内同时运行。</li>
<li>独立性：进程实体是一个能独立运行、独立获取资源、独立接收调度的基本单位。</li>
<li>异步性：进程按异步方式运行。</li>
</ul>
<p><b>进程的五种基本状态及转换</b> <font color='red'>★★★</font></p>
<img src='/img/操作系统期末复习/img6'>

<p><b>进程的创建</b></p>
<ul>
<li>申请空白PCB。</li>
<li>为新进程分配其运行所需的资源。</li>
<li>初始化进程控制(PCB)。</li>
<li>如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列。</li>
</ul>
<p>&nbsp;</p>
<p><b>临界区</b> <font color='red'>★★★</font></p>
<p>访问临界资源的代码称为<b>临界区</b>。对临界资源的访问是<b>互斥访问</b>。</p>
<p>进访问区前，对欲访问的临界资源进行检查。若该临界资源正被某个资源访问的时候，不能进入临界区。因此在临界区前加一段检查代码，称为<b>进入区</b>。临界区后面加一段代码，称为<b>退出区</b>。剩余部分称为<b>剩余区</b>。</p>
<p>代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while(TURE)</span><br><span class="line">&#123;</span><br><span class="line">    进入区</span><br><span class="line">    临界区</span><br><span class="line">    退出区</span><br><span class="line">    剩余区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&nbsp;</p>
<p><b>利用信号量实现进程互斥</b></p>
<ul>
<li><p>设 mutex 为互斥信号量，初值为 1，取值范围（-1，0，1）。当mutex=1时，表示两个进程都没进入需要互斥的临界区；当mutex=0时，表示有一个进程进入临界区运行，另一个必须进行等待，挂入阻塞队列。当mutex=-1时，表示有一个进程正在临界区运行，另外一个进程因等待而阻塞在信号量队列中，需要被当前已在临界区运行的进程退出时唤醒。</p>
</li>
<li><p>代码：</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex &#x3D; 1</span><br><span class="line">Pa()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        wait(mutex);</span><br><span class="line">        临界区;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        剩余区;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Pb()&#123;</span><br><span class="line">    while(1)&#123;</span><br><span class="line">        wait(mutex);</span><br><span class="line">        临界区;</span><br><span class="line">        signal(mutex);</span><br><span class="line">        剩余区;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>&nbsp;</p>
<p><b>线程的引入</b> <font color='red'>★★★</font></p>
<p>线程的引入使 OS 具有更好的并发性。</p>
<ul>
<li><p>进程的两个进本属性：</p>
<ol>
<li>进程是一个可拥有资源的独立单位，一个进程要能独立运行，它必须拥有一定的资源。</li>
<li>进程同时又是一个可独立调度和分派的基本单位，一个进程要能独立运行，它还必须是一个可独立调度和分派的基本单位。</li>
</ol>
</li>
<li><p>为使程序能并发执行，系统必须进行以下操作</p>
<ol>
<li>创建进程</li>
<li>撤销进程</li>
<li>进程切换</li>
</ol>
</li>
<li><p>线程——作为调度和分派的基本单位</p>
</li>
</ul>
<hr>
<h2 id="处理机调度与死锁"><a href="#处理机调度与死锁" class="headerlink" title="处理机调度与死锁"></a>处理机调度与死锁</h2><p><b>平均周转时间</b></p>
<p>完成时间=等待时间+时间片大小*距离完成相差进程数<br>周转时间=完成时间-服务时间<br>带权周转时间=周转时间/服务时间<br>平均周转时间=周转时间总和/进程数<br>带权平均周转时间=带权周转时间总和/进程数</p>
<p><b>短作业优先调度算法 SJF算法</b></p>
<p>书P101</p>
<p><b>死锁的概念</b> <font color='red'>★★★</font></p>
<p>死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。</p>
<p><b>死锁的定义</b> <font color='red'>★★★</font></p>
<p>如果一组进程中的每一个进程都在等待仅由该组进程中的其他进程才能引发的事件，那么该组进程是死锁的。</p>
<p><b>产生死锁的必要条件</b></p>
<ul>
<li>互斥条件：进程对所分配到的资源进行排他性使用。</li>
<li>请求和保持条件：进程已经保持了至少一个资源，但又提出新的资源请求，该资源已被其他进程占有。</li>
<li>不可抢占条件：进程已获得的资源在未使用前不能被抢占，只能在进程使用完时由自己释放。</li>
<li>循环等待条件：在发生死锁时，必然存在一个进程——资源的循环链中的第一个资源在等待下一个资源，下一个资源在等待下下一个资源，最后一个资源在等待被第一个资源所占用的资源。</li>
</ul>
<p><b>处理死锁的方法</b></p>
<ul>
<li>预防死锁：设置限制条件，破坏产生死锁的四个必要条件中的一个或几个来预防死锁产生。</li>
<li>避免死锁：在资源动态分配程中，用某种方法防止系统进入不安全状态。</li>
<li>检测死锁：通过检测机构及时地检测出死锁的发生，然后采取适当的措施，将进程从死锁中解脱出来。</li>
<li>解除死锁：常用方法是撤销一些进程，回收它们的资源，将其分配给已堵塞的资源使其运行。</li>
</ul>
<p><b>避免死锁</b> <font color='red'>★★★</font></p>
<p>银行家算法，书P119</p>
<hr>
<h2 id="第四章-存储器管理"><a href="#第四章-存储器管理" class="headerlink" title="第四章 存储器管理"></a>第四章 存储器管理</h2><p><b>连续分配存储管理方式</b></p>
<ul>
<li>单一连续分配</li>
<li>固定分区分配</li>
<li>动态分区分配</li>
</ul>
<p><b>基于顺序搜索的动态分区分配算法</b></p>
<ul>
<li>首次适应算法(FF算法)</li>
<li>循环首次适应算法(NF算法)</li>
<li>最佳适应算法(BF算法)</li>
<li>最坏适应算法(WF算法)</li>
</ul>
<p><b>分页存储管理方式</b> <font color='red'>★★★</font></p>
<p>分页地址结构：<br>二进制下，前11位是偏移量，后最多20位是页号，比如偏移量800，即地址结构内偏移量为01100100000，属于第2页，最大为8页，其页号为1000，则第二页页号为0010。其地址结构为0010,01100100000</p>
<p><b>分段存储管理方式</b></p>
<p>分段地址结构：<br>二进制下，前15位是偏移量，后最多15位是页号，比如偏移量800，即地址结构内偏移量为000001100100000，属于第2页，最大为8页，其页号为1000，则第二页页号为0010。其地址结构为0010,000001100100000</p>
<hr>
<h2 id="第五章-虚拟存储器"><a href="#第五章-虚拟存储器" class="headerlink" title="第五章 虚拟存储器"></a>第五章 虚拟存储器</h2><p><b>虚拟存储器的定义</b></p>
<p>指具有请求调入功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统。其逻辑容量由内存容量和外存容量之和所决定，其运行速度接近于内存速度。</p>
<p><b>虚拟存储器的实现方法</b></p>
<ul>
<li><p>分页请求系统</p>
<p>  在分页系统基础上增加了请求调页功能和页面置换功能所形成的页式虚拟存储系统。</p>
<ul>
<li><p>硬件支持</p>
<ol>
<li>请求分页的页表机制：作为请求分页的数据结构。</li>
<li>缺页中断机构：每当用户程序要访问的页面尚未调入内存时，便产生一缺页中断，以请求OS将所缺的页调入内存。</li>
<li>地址变换机构：在纯分页地址变换机构的基础上发展形成的。</li>
</ol>
</li>
<li><p>软件支持</p>
<p>  包括用于实现请求调页的软件和实现页面置换的软件。</p>
</li>
</ul>
</li>
<li><p>请求分段系统</p>
<p>  在分段系统基础上，增加了请求调段及分段置换功能后所形成的段式虚拟存储系统。</p>
<ul>
<li><p>硬件支持</p>
<ol>
<li>请求分段的段表机制：作为请求分段的数据结构。</li>
<li>缺段中断机构：每当用户程序要访问的段尚未调入内存时，便产生一缺段中断，以请求OS将所缺的段调入内存。</li>
<li>地址变换机构：在纯分段地址变换机构的基础上发展形成的。</li>
</ol>
</li>
<li><p>软件支持：</p>
<p>  包括用于实现请求调段的软件和实现段置换的软件。</p>
</li>
</ul>
</li>
</ul>
<hr>
<h2 id="第六章-输入输出系统"><a href="#第六章-输入输出系统" class="headerlink" title="第六章 输入输出系统"></a>第六章 输入输出系统</h2><p><b>假脱机(Spooling)系统</b></p>
<p>假脱机系统构成部分：</p>
<ul>
<li>输入井和输出井。</li>
<li>输入缓冲区和输出缓冲区。</li>
<li>输入进程和输出进程。</li>
<li>井管理程序。</li>
</ul>
<p>假脱机系统特点：</p>
<ul>
<li>提高了I/O的速度。</li>
<li>将独占设备改造为共享设备。</li>
<li>实现了虚拟设备功能。</li>
</ul>
<p><b>磁盘调度算法</b></p>
<p>书P233</p>
<hr>
<h2 id="第七章-文件管理"><a href="#第七章-文件管理" class="headerlink" title="第七章 文件管理"></a>第七章 文件管理</h2><p><b>数据项</b></p>
<ul>
<li>基本数据项：又称字段。</li>
<li>组合数据项：若干基本数据项组成。</li>
</ul>
<p><b>记录</b></p>
<p>是一组相关数据项的集合，用于描述一个对象在某方面的属性。</p>
<p><b>文件</b></p>
<p>文件指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构稳健两种。</p>
<p>文件的属性包括：</p>
<ul>
<li>文件类型。</li>
<li>文件长度。</li>
<li>文件的物理位置。</li>
<li>文件的建立时间。</li>
</ul>
<p>文件包括文件名和拓展名。</p>
<p>文件类型：</p>
<p>按用途分类：</p>
<ul>
<li>系统文件：不可读写。</li>
<li>用户文件：指由用户的源代码、目标文件、可执行文件或数据所构成的文件。</li>
<li>库文件：由标准子例程及常用的例程所构成的文件。</li>
</ul>
<p>按文件中数据形式分类：</p>
<ul>
<li>源文件</li>
<li>目标文件（.obj）</li>
<li>可执行文件（.exe）</li>
</ul>
<p>按存取控制属性分类：</p>
<ul>
<li>只执行文件（不可读写）</li>
<li>只读文件（不可写）</li>
<li>读写文件</li>
</ul>
<p>按组织形式和处理方式分类：</p>
<ul>
<li>普通文件</li>
<li>目录文件</li>
<li>特殊文件</li>
</ul>
<p><b>文件管理系统管理对象</b></p>
<ul>
<li>文件。</li>
<li>目录。</li>
<li>磁盘存储空间。</li>
</ul>
<p>文件系统接口：</p>
<ul>
<li>命令接口。</li>
<li>程序接口。</li>
</ul>
<p>最基本文件操作：</p>
<ul>
<li>创建文件。</li>
<li>删除文件。</li>
<li>读文件。</li>
<li>写文件。</li>
<li>设置文件读写位置。</li>
</ul>
<h2 id="雨课堂习题"><a href="#雨课堂习题" class="headerlink" title="雨课堂习题"></a>雨课堂习题</h2><p><b>选择</b></p>
<p>在计算机系统中配置操作系统的主要目的是<b><font color='red'>提高系统资源的利用率</font></b></p>
<p>操作系统的主要功能是管理计算机系统中的<b><font color='red'>资源</font></b></p>
<p>在<b><font color='red'>实时操作系统</font></b>的控制下，计算机系统能及时处理由该过程控制反馈的数据，并作出响应。</p>
<p>下面描述正确的是<b><font color='red'>并发性是指若干事件在同一时间间隔内发生</font></b></p>
<ul>
<li>易错：<b><font color='blue'>并发性是指若干时间在同一时刻内发生</font></b></li>
</ul>
<p>Windows XP 是一个<b><font color='red'>单用户多任务操作系统</font></b>。</p>
<p>下列进程状态转换中，绝对不可能发生的状态转换是<b><font color='red'>就绪-&gt;堵塞</font></b></p>
<p>对于记录型信号量，在执行一次wait操作时，信号量的值应当<b><font color='red'>减1</font></b></p>
<p>下面对临界区的论述中，正确的是<b><font color='red'>临界区是指进程中访问临界资源的那段代码</font></b>。</p>
<p>对于记录型信号量，在执行signal操作时，当其值为<b><font color='red'>小于等于0</font></b>时，应唤醒阻塞队列中的进程。</p>
<p>作业调度是从处于<b><font color='red'>后备</font></b>状态的队列中选取作业投入运行。</p>
<p><b><font color='red'>周转时间</font></b>是指作业进入系统到作业完成所经过的时间间隔。</p>
<p>下列算法，<b><font color='red'>FCFS调度算法</font></b>只能采用非抢占调度方式。</p>
<p>系统产生死锁是指<b><font color='red'>若干进程等待被其他进程所占用而又不可能被释放的资源</font></b>。</p>
<p>下列解决死锁的方法中，属于死锁避免策略的是<b><font color='red'>银行家算法</font></b>。</p>
<p>下列解决死锁的方法中，属于死锁预防策略的是<b><font color='red'>资源有序分配法</font></b>。</p>
<p>从下列关于非虚拟存储器的论述中，选出一条正确的论述。<b><font color='red'>要求作业在运行前，必须全部装入内存，且在运行过程中也必须一直驻留内存。</font></b></p>
<p>提高内存利用率主要通过<b><font color='red'>内存分配</font></b>功能实现。</p>
<p>&nbsp;</p>
<p><b>填空</b></p>
<p>操作系统最基本的特征是<b><font color='red'>并发</font></b>和<b><font color='red'>共享</font></b>，最主要的任务是<b><font color='red'>管理资源</font></b>。</p>
<p>引入进程的主要目的是<b><font color='red'>并发执行</font></b>，进程存在的唯一标志是<b><font color='red'>PCB</font></b>。</p>
<p>从静态的角度看，进程是由<b><font color='red'>程序段</font></b>、<b><font color='red'>数据段</font></b>、<b><font color='red'>进程控制块（PCB）</font></b>三部分组成。</p>
<p>在生产者——消费者问题中，应该设置互斥信号量mutex、资源信号量full和empty，它们的初值分别是<b><font color='red'>1</font></b>、<b><font color='red'>0</font></b>、<b><font color='red'>n</font></b>。</p>
<p>&nbsp;</p>
<p><b>主观题</b></p>
<img src='/img/操作系统期末复习/img1.jpg'>

<img src='/img/操作系统期末复习/img2.jpg'>

<img src='/img/操作系统期末复习/img3.jpg'>
            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="/music/塞壬唱片-MSR - Renegade.mp3">
            </audio>
            
        </div>
        
    <div id='gitalk-container' class="comment link"
		data-enable='true'
        data-ae='false'
        data-ci=''
        data-cs=''
        data-r=''
        data-o=''
        data-a=''
        data-d='false'
    >查看评论</div>


    </div>
    
        <div class='side'>
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#第一章-操作系统（OS）引论"><span class="toc-number">1.</span> <span class="toc-text">第一章 操作系统（OS）引论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第二章-进程的描述与控制"><span class="toc-number">2.</span> <span class="toc-text">第二章 进程的描述与控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#处理机调度与死锁"><span class="toc-number">3.</span> <span class="toc-text">处理机调度与死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第四章-存储器管理"><span class="toc-number">4.</span> <span class="toc-text">第四章 存储器管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第五章-虚拟存储器"><span class="toc-number">5.</span> <span class="toc-text">第五章 虚拟存储器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第六章-输入输出系统"><span class="toc-number">6.</span> <span class="toc-text">第六章 输入输出系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#第七章-文件管理"><span class="toc-number">7.</span> <span class="toc-text">第七章 文件管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#雨课堂习题"><span class="toc-number">8.</span> <span class="toc-text">雨课堂习题</span></a></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>






</html>
